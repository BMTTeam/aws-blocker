#!/bin/bash -e

POSITION=1
FILTERS=""

# Get the line where the jump will be inserted at.
# Useful if you want e.g related / established rules for outgoing traffic.
if [[ -n $1 ]]; then
    POSITION=$1
fi

# Process region filter statements
for arg in ${@:2}; do
    if [[ -n $FILTERS ]]; then
        FILTERS=$FILTERS", "
    fi

    FILTERS=$FILTERS"select(.region | contains(\"$arg\"))"
done

if [[ -n $FILTERS ]]; then
    FILTERS=" | "$FILTERS
fi

GROUP='group_by(.ip_prefix)'
MAP='map({ "ip": .[0].ip_prefix, "regions": map(.region) | unique, "services": map(.service) | unique })'
TO_STRING='.ip + " \"" + (.regions | sort | join (", ")) + "\" \"" + (.services | sort | join (", ")) + "\""'

PROCESS="$GROUP | $MAP | .[] | $TO_STRING"


# Create the AWS iptables chain if it doesn't exist
iptables -n --list AWS >/dev/null 2>&1 \
    || (iptables -N AWS && iptables -I INPUT $POSITION -j AWS)

# Flush the existing AWS iptables chain
iptables -F AWS

# Get list of IP ranges
#
# First we use curl to grab the official list of ranges from Amazon. The -s
# prevents extraneous output from curl, and the -L makes it follow redirects.
#
# The ranges are passed to jq, a JSON parser. The -r makes jq output raw data
# without quotes. We only need the list of prefixes, so we discard everything
# else.
RANGES=$(curl -s -L https://ip-ranges.amazonaws.com/ip-ranges.json \
    | jq -r "[ .prefixes[]$FILTERS ] | $PROCESS" \
    | sort -Vu \
)


# Loop through the ranges, adding each to iptables
IFS=$'\n' LINES=($RANGES)
unset IFS

for line in "${LINES[@]}"; do
    eval DATA=($line)
    IP=${DATA[0]}
    REGIONS=$(echo ${DATA[1]} | tr '[:upper:]' '[:lower:]')
    SERVICES=$(echo ${DATA[2]} | tr '[:upper:]' '[:lower:]')

    iptables -A AWS -s "$IP" -j REJECT -m comment --comment "$REGIONS = $SERVICES"
done
